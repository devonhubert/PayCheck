{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/devonhubert/languages/javascript/react_native/PayCheck/node_modules/react-navigation-drawer/dist/views/DrawerLayout.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport Keyboard from \"react-native-web/dist/exports/Keyboard\";\nimport StatusBar from \"react-native-web/dist/exports/StatusBar\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport invariant from \"../utils/invariant\";\nimport { PanGestureHandler, TapGestureHandler, State } from 'react-native-gesture-handler';\nvar DRAG_TOSS = 0.05;\nvar IDLE = 'Idle';\nvar DRAGGING = 'Dragging';\nvar SETTLING = 'Settling';\n\nvar DrawerLayout = function (_Component) {\n  _inherits(DrawerLayout, _Component);\n\n  var _super = _createSuper(DrawerLayout);\n\n  function DrawerLayout(_props, context) {\n    var _this;\n\n    _classCallCheck(this, DrawerLayout);\n\n    _this = _super.call(this, _props, context);\n\n    _this._updateAnimatedEvent = function (props, state) {\n      var drawerPosition = props.drawerPosition,\n          drawerWidth = props.drawerWidth,\n          drawerType = props.drawerType;\n      var dragXValue = state.dragX,\n          touchXValue = state.touchX,\n          drawerTranslation = state.drawerTranslation,\n          containerWidth = state.containerWidth;\n      var dragX = dragXValue;\n      var touchX = touchXValue;\n\n      if (drawerPosition !== 'left') {\n        dragX = Animated.multiply(new Animated.Value(-1), dragXValue);\n        touchX = Animated.add(new Animated.Value(containerWidth), Animated.multiply(new Animated.Value(-1), touchXValue));\n        touchXValue.setValue(containerWidth);\n      } else {\n        touchXValue.setValue(0);\n      }\n\n      var translationX = dragX;\n\n      if (drawerType === 'front') {\n        var startPositionX = Animated.add(touchX, Animated.multiply(new Animated.Value(-1), dragX));\n        var dragOffsetFromOnStartPosition = startPositionX.interpolate({\n          inputRange: [drawerWidth - 1, drawerWidth, drawerWidth + 1],\n          outputRange: [0, 0, 1]\n        });\n        translationX = Animated.add(dragX, dragOffsetFromOnStartPosition);\n      }\n\n      _this._openValue = Animated.add(translationX, drawerTranslation).interpolate({\n        inputRange: [0, drawerWidth],\n        outputRange: [0, 1],\n        extrapolate: 'clamp'\n      });\n      _this._onGestureEvent = Animated.event([{\n        nativeEvent: {\n          translationX: dragXValue,\n          x: touchXValue\n        }\n      }], {\n        useNativeDriver: props.useNativeAnimations\n      });\n    };\n\n    _this._handleContainerLayout = function (_ref) {\n      var nativeEvent = _ref.nativeEvent;\n\n      _this.setState({\n        containerWidth: nativeEvent.layout.width\n      });\n    };\n\n    _this._emitStateChanged = function (newState, drawerWillShow) {\n      _this.props.onDrawerStateChanged && _this.props.onDrawerStateChanged(newState, drawerWillShow);\n    };\n\n    _this._openingHandlerStateChange = function (_ref2) {\n      var nativeEvent = _ref2.nativeEvent;\n\n      if (nativeEvent.oldState === State.ACTIVE) {\n        _this._handleRelease(nativeEvent);\n      } else if (nativeEvent.state === State.ACTIVE) {\n        _this._emitStateChanged(DRAGGING, false);\n\n        if (_this.props.keyboardDismissMode === 'on-drag') {\n          Keyboard.dismiss();\n        }\n\n        if (_this.props.hideStatusBar) {\n          StatusBar.setHidden(true, _this.props.statusBarAnimation || 'slide');\n        }\n      }\n    };\n\n    _this._onTapHandlerStateChange = function (_ref3) {\n      var nativeEvent = _ref3.nativeEvent;\n\n      if (_this.state.drawerShown && nativeEvent.oldState === State.ACTIVE && _this.props.drawerLockMode !== 'locked-open') {\n        _this.closeDrawer();\n      }\n    };\n\n    _this._handleRelease = function (nativeEvent) {\n      var _this$props = _this.props,\n          drawerWidth = _this$props.drawerWidth,\n          drawerPosition = _this$props.drawerPosition,\n          drawerType = _this$props.drawerType;\n      var _this$state = _this.state,\n          drawerShown = _this$state.drawerShown,\n          containerWidth = _this$state.containerWidth;\n      var dragX = nativeEvent.translationX,\n          velocityX = nativeEvent.velocityX,\n          touchX = nativeEvent.x;\n\n      if (drawerPosition !== 'left') {\n        dragX = -dragX;\n        touchX = containerWidth - touchX;\n        velocityX = -velocityX;\n      }\n\n      var gestureStartX = touchX - dragX;\n      var dragOffsetBasedOnStart = 0;\n\n      if (drawerType === 'front') {\n        dragOffsetBasedOnStart = gestureStartX > drawerWidth ? gestureStartX - drawerWidth : 0;\n      }\n\n      var startOffsetX = dragX + dragOffsetBasedOnStart + (drawerShown ? drawerWidth : 0);\n      var projOffsetX = startOffsetX + DRAG_TOSS * velocityX;\n      var shouldOpen = projOffsetX > drawerWidth / 2;\n\n      if (shouldOpen) {\n        _this._animateDrawer({\n          fromValue: startOffsetX,\n          toValue: drawerWidth,\n          velocity: velocityX\n        });\n      } else {\n        _this._animateDrawer({\n          fromValue: startOffsetX,\n          toValue: 0,\n          velocity: velocityX\n        });\n      }\n    };\n\n    _this._animateDrawer = function (_ref4) {\n      var fromValue = _ref4.fromValue,\n          toValue = _ref4.toValue,\n          velocity = _ref4.velocity;\n\n      _this.state.dragX.setValue(0);\n\n      _this.state.touchX.setValue(_this.props.drawerPosition === 'left' ? 0 : _this.state.containerWidth);\n\n      if (typeof fromValue === 'number') {\n        _this.state.drawerTranslation.setValue(fromValue);\n      }\n\n      var willShow = toValue !== 0;\n\n      _this.setState({\n        drawerShown: willShow\n      });\n\n      _this._emitStateChanged(SETTLING, willShow);\n\n      if (_this.props.hideStatusBar) {\n        StatusBar.setHidden(willShow, _this.props.statusBarAnimation || 'slide');\n      }\n\n      Animated.spring(_this.state.drawerTranslation, {\n        velocity: velocity,\n        bounciness: 0,\n        toValue: toValue,\n        useNativeDriver: _this.props.useNativeAnimations\n      }).start(function (_ref5) {\n        var finished = _ref5.finished;\n\n        if (finished) {\n          _this._emitStateChanged(IDLE, willShow);\n\n          if (willShow) {\n            _this.props.onDrawerOpen && _this.props.onDrawerOpen();\n          } else {\n            _this.props.onDrawerClose && _this.props.onDrawerClose();\n          }\n        }\n      });\n    };\n\n    _this.openDrawer = function () {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _this._animateDrawer({\n        toValue: _this.props.drawerWidth,\n        velocity: options.velocity ? options.velocity : 0\n      });\n    };\n\n    _this.closeDrawer = function () {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _this._animateDrawer({\n        toValue: 0,\n        velocity: options.velocity ? options.velocity : 0\n      });\n    };\n\n    _this._renderOverlay = function () {\n      invariant(_this._openValue, 'should be set');\n\n      var overlayOpacity = _this._openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: [0, 0.7],\n        extrapolate: 'clamp'\n      });\n\n      var dynamicOverlayStyles = {\n        opacity: overlayOpacity,\n        backgroundColor: _this.props.overlayColor\n      };\n      return React.createElement(TapGestureHandler, {\n        onHandlerStateChange: _this._onTapHandlerStateChange,\n        __self: _assertThisInitialized(_this),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 270,\n          columnNumber: 12\n        }\n      }, React.createElement(Animated.View, {\n        pointerEvents: _this.state.drawerShown ? 'auto' : 'none',\n        style: [styles.overlay, dynamicOverlayStyles],\n        __self: _assertThisInitialized(_this),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 271,\n          columnNumber: 9\n        }\n      }));\n    };\n\n    _this._renderDrawer = function () {\n      var drawerShown = _this.state.drawerShown;\n      var _this$props2 = _this.props,\n          drawerBackgroundColor = _this$props2.drawerBackgroundColor,\n          drawerWidth = _this$props2.drawerWidth,\n          drawerPosition = _this$props2.drawerPosition,\n          drawerType = _this$props2.drawerType,\n          contentContainerStyle = _this$props2.contentContainerStyle;\n      var fromLeft = drawerPosition === 'left';\n      var drawerSlide = drawerType !== 'back';\n      var containerSlide = drawerType !== 'front';\n      var dynamicDrawerStyles = {\n        backgroundColor: drawerBackgroundColor,\n        width: drawerWidth\n      };\n      var openValue = _this._openValue;\n      invariant(openValue, 'should be set');\n      var containerStyles;\n\n      if (containerSlide) {\n        var containerTranslateX = openValue.interpolate({\n          inputRange: [0, 1],\n          outputRange: fromLeft ? [0, drawerWidth] : [0, -drawerWidth],\n          extrapolate: 'clamp'\n        });\n        containerStyles = {\n          transform: [{\n            translateX: containerTranslateX\n          }]\n        };\n      }\n\n      var drawerTranslateX = 0;\n\n      if (drawerSlide) {\n        var closedDrawerOffset = fromLeft ? -drawerWidth : drawerWidth;\n        drawerTranslateX = openValue.interpolate({\n          inputRange: [0, 1],\n          outputRange: [closedDrawerOffset, 0],\n          extrapolate: 'clamp'\n        });\n      }\n\n      var drawerStyles = {\n        transform: [{\n          translateX: drawerTranslateX\n        }],\n        flexDirection: (I18nManager.isRTL ? !fromLeft : fromLeft) ? 'row' : 'row-reverse'\n      };\n      return React.createElement(Animated.View, {\n        style: styles.main,\n        onLayout: _this._handleContainerLayout,\n        __self: _assertThisInitialized(_this),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 322,\n          columnNumber: 12\n        }\n      }, React.createElement(Animated.View, {\n        style: [drawerType === 'front' ? styles.containerOnBack : styles.containerInFront, containerStyles, contentContainerStyle],\n        __self: _assertThisInitialized(_this),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 323,\n          columnNumber: 9\n        }\n      }, typeof _this.props.children === 'function' ? _this.props.children(_this._openValue) : _this.props.children, _this._renderOverlay()), React.createElement(Animated.View, {\n        pointerEvents: \"box-none\",\n        accessibilityViewIsModal: drawerShown,\n        style: [styles.drawerContainer, drawerStyles],\n        __self: _assertThisInitialized(_this),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 327,\n          columnNumber: 9\n        }\n      }, React.createElement(View, {\n        style: [styles.drawer, dynamicDrawerStyles],\n        __self: _assertThisInitialized(_this),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 328,\n          columnNumber: 11\n        }\n      }, _this.props.renderNavigationView(_this._openValue))));\n    };\n\n    var _dragX = new Animated.Value(0);\n\n    var _touchX = new Animated.Value(0);\n\n    var _drawerTranslation = new Animated.Value(0);\n\n    _this.state = {\n      dragX: _dragX,\n      touchX: _touchX,\n      drawerTranslation: _drawerTranslation,\n      drawerShown: false,\n      containerWidth: 0\n    };\n\n    _this._updateAnimatedEvent(_props, _this.state);\n\n    return _this;\n  }\n\n  _createClass(DrawerLayout, [{\n    key: \"componentWillUpdate\",\n    value: function componentWillUpdate(props, state) {\n      if (this.props.drawerPosition !== props.drawerPosition || this.props.drawerWidth !== props.drawerWidth || this.props.drawerType !== props.drawerType || this.state.containerWidth !== state.containerWidth) {\n        this._updateAnimatedEvent(props, state);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$state2 = this.state,\n          drawerShown = _this$state2.drawerShown,\n          containerWidth = _this$state2.containerWidth;\n      var _this$props3 = this.props,\n          drawerPosition = _this$props3.drawerPosition,\n          drawerType = _this$props3.drawerType,\n          drawerLockMode = _this$props3.drawerLockMode,\n          edgeWidth = _this$props3.edgeWidth,\n          minSwipeDistance = _this$props3.minSwipeDistance;\n      var fromLeft = drawerPosition === 'left';\n      var gestureOrientation = (fromLeft ? 1 : -1) * (drawerShown ? -1 : 1);\n      var hitSlop = fromLeft ? {\n        right: drawerShown ? 0 : edgeWidth - containerWidth\n      } : {\n        left: drawerShown ? 0 : edgeWidth - containerWidth\n      };\n      return React.createElement(PanGestureHandler, {\n        hitSlop: hitSlop,\n        minOffsetX: gestureOrientation * minSwipeDistance,\n        maxDeltaY: 15,\n        onGestureEvent: this._onGestureEvent,\n        enabled: drawerLockMode !== 'locked-closed' && drawerLockMode !== 'locked-open',\n        onHandlerStateChange: this._openingHandlerStateChange,\n        ref: this.props.gestureRef,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 358,\n          columnNumber: 12\n        }\n      }, this._renderDrawer());\n    }\n  }]);\n\n  return DrawerLayout;\n}(Component);\n\nDrawerLayout.defaultProps = {\n  drawerWidth: 200,\n  drawerPosition: 'left',\n  useNativeAnimations: true,\n  drawerType: 'front',\n  edgeWidth: 20,\n  minSwipeDistance: 3,\n  overlayColor: 'black',\n  drawerLockMode: 'unlocked'\n};\nDrawerLayout.positions = {\n  Left: 'left',\n  Right: 'right'\n};\nexport { DrawerLayout as default };\nvar styles = StyleSheet.create({\n  drawer: {\n    flex: 0\n  },\n  drawerContainer: _objectSpread(_objectSpread({}, StyleSheet.absoluteFillObject), {}, {\n    zIndex: 1001,\n    flexDirection: 'row'\n  }),\n  containerInFront: _objectSpread(_objectSpread({}, StyleSheet.absoluteFillObject), {}, {\n    zIndex: 1002\n  }),\n  containerOnBack: _objectSpread({}, StyleSheet.absoluteFillObject),\n  main: {\n    flex: 1,\n    zIndex: 0,\n    overflow: 'hidden'\n  },\n  overlay: _objectSpread(_objectSpread({}, StyleSheet.absoluteFillObject), {}, {\n    zIndex: 1000\n  })\n});","map":{"version":3,"sources":["/Users/devonhubert/languages/javascript/react_native/PayCheck/node_modules/react-navigation-drawer/dist/views/DrawerLayout.js"],"names":["React","Component","invariant","PanGestureHandler","TapGestureHandler","State","DRAG_TOSS","IDLE","DRAGGING","SETTLING","DrawerLayout","props","context","_updateAnimatedEvent","state","drawerPosition","drawerWidth","drawerType","dragXValue","dragX","touchXValue","touchX","drawerTranslation","containerWidth","Animated","multiply","Value","add","setValue","translationX","startPositionX","dragOffsetFromOnStartPosition","interpolate","inputRange","outputRange","_openValue","extrapolate","_onGestureEvent","event","nativeEvent","x","useNativeDriver","useNativeAnimations","_handleContainerLayout","setState","layout","width","_emitStateChanged","newState","drawerWillShow","onDrawerStateChanged","_openingHandlerStateChange","oldState","ACTIVE","_handleRelease","keyboardDismissMode","Keyboard","dismiss","hideStatusBar","StatusBar","setHidden","statusBarAnimation","_onTapHandlerStateChange","drawerShown","drawerLockMode","closeDrawer","velocityX","gestureStartX","dragOffsetBasedOnStart","startOffsetX","projOffsetX","shouldOpen","_animateDrawer","fromValue","toValue","velocity","willShow","spring","bounciness","start","finished","onDrawerOpen","onDrawerClose","openDrawer","options","_renderOverlay","overlayOpacity","dynamicOverlayStyles","opacity","backgroundColor","overlayColor","styles","overlay","_renderDrawer","drawerBackgroundColor","contentContainerStyle","fromLeft","drawerSlide","containerSlide","dynamicDrawerStyles","openValue","containerStyles","containerTranslateX","transform","translateX","drawerTranslateX","closedDrawerOffset","drawerStyles","flexDirection","I18nManager","isRTL","main","containerOnBack","containerInFront","children","drawerContainer","drawer","renderNavigationView","edgeWidth","minSwipeDistance","gestureOrientation","hitSlop","right","left","gestureRef","defaultProps","positions","Left","Right","StyleSheet","create","flex","absoluteFillObject","zIndex","overflow"],"mappings":"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","sourcesContent":["/* eslint-disable */\n\n// #########################################################\n//    This is vendored from react-native-gesture-handler!\n// #########################################################\n\n// This component is based on RN's DrawerLayoutAndroid API\n//\n// It perhaps deserves to be put in a separate repo, but since it relies\n// on react-native-gesture-handler library which isn't very popular at the\n// moment I decided to keep it here for the time being. It will allow us\n// to move faster and fix issues that may arise in gesture handler library\n// that could be found when using the drawer component\n\nimport React, { Component } from 'react';\nimport { Animated, StyleSheet, View, Keyboard, StatusBar, I18nManager } from 'react-native';\nimport invariant from '../utils/invariant';\n\nimport { PanGestureHandler, TapGestureHandler, State } from 'react-native-gesture-handler';\n\nconst DRAG_TOSS = 0.05;\n\nconst IDLE = 'Idle';\nconst DRAGGING = 'Dragging';\nconst SETTLING = 'Settling';\n\nexport default class DrawerLayout extends Component {\n  static defaultProps = {\n    drawerWidth: 200,\n    drawerPosition: 'left',\n    useNativeAnimations: true,\n    drawerType: 'front',\n    edgeWidth: 20,\n    minSwipeDistance: 3,\n    overlayColor: 'black',\n    drawerLockMode: 'unlocked'\n  };\n\n  static positions = {\n    Left: 'left',\n    Right: 'right'\n  };\n\n\n  constructor(props, context) {\n    super(props, context);\n\n    const dragX = new Animated.Value(0);\n    const touchX = new Animated.Value(0);\n    const drawerTranslation = new Animated.Value(0);\n\n    this.state = {\n      dragX,\n      touchX,\n      drawerTranslation,\n      drawerShown: false,\n      containerWidth: 0\n    };\n\n    this._updateAnimatedEvent(props, this.state);\n  }\n\n  componentWillUpdate(props, state) {\n    if (this.props.drawerPosition !== props.drawerPosition || this.props.drawerWidth !== props.drawerWidth || this.props.drawerType !== props.drawerType || this.state.containerWidth !== state.containerWidth) {\n      this._updateAnimatedEvent(props, state);\n    }\n  }\n\n  _updateAnimatedEvent = (props, state) => {\n    // Event definition is based on\n    const { drawerPosition, drawerWidth, drawerType } = props;\n    const {\n      dragX: dragXValue,\n      touchX: touchXValue,\n      drawerTranslation,\n      containerWidth\n    } = state;\n\n    let dragX = dragXValue;\n    let touchX = touchXValue;\n\n    if (drawerPosition !== 'left') {\n      // Most of the code is written in a way to handle left-side drawer.\n      // In order to handle right-side drawer the only thing we need to\n      // do is to reverse events coming from gesture handler in a way they\n      // emulate left-side drawer gestures. E.g. dragX is simply -dragX, and\n      // touchX is calulcated by subtracing real touchX from the width of the\n      // container (such that when touch happens at the right edge the value\n      // is simply 0)\n      dragX = Animated.multiply(new Animated.Value(-1), dragXValue);\n      touchX = Animated.add(new Animated.Value(containerWidth), Animated.multiply(new Animated.Value(-1), touchXValue));\n      touchXValue.setValue(containerWidth);\n    } else {\n      touchXValue.setValue(0);\n    }\n\n    // While closing the drawer when user starts gesture outside of its area (in greyed\n    // out part of the window), we want the drawer to follow only once finger reaches the\n    // edge of the drawer.\n    // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by\n    // dots. The touch gesture starts at '*' and moves left, touch path is indicated by\n    // an arrow pointing left\n    // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    +---------------+    +---------------+    +---------------+    +---------------+\n    //\n    // For the above to work properly we define animated value that will keep start position\n    // of the gesture. Then we use that value to calculate how much we need to subtract from\n    // the dragX. If the gesture started on the greyed out area we take the distance from the\n    // edge of the drawer to the start position. Otherwise we don't subtract at all and the\n    // drawer be pulled back as soon as you start the pan.\n    //\n    // This is used only when drawerType is \"front\"\n    //\n    let translationX = dragX;\n    if (drawerType === 'front') {\n      const startPositionX = Animated.add(touchX, Animated.multiply(new Animated.Value(-1), dragX));\n\n      const dragOffsetFromOnStartPosition = startPositionX.interpolate({\n        inputRange: [drawerWidth - 1, drawerWidth, drawerWidth + 1],\n        outputRange: [0, 0, 1]\n      });\n      translationX = Animated.add(dragX, dragOffsetFromOnStartPosition);\n    }\n\n    this._openValue = Animated.add(translationX, drawerTranslation).interpolate({\n      inputRange: [0, drawerWidth],\n      outputRange: [0, 1],\n      extrapolate: 'clamp'\n    });\n\n    this._onGestureEvent = Animated.event([{ nativeEvent: { translationX: dragXValue, x: touchXValue } }], { useNativeDriver: props.useNativeAnimations });\n  };\n\n  _handleContainerLayout = ({ nativeEvent }) => {\n    this.setState({ containerWidth: nativeEvent.layout.width });\n  };\n\n  _emitStateChanged = (newState, drawerWillShow) => {\n    this.props.onDrawerStateChanged && this.props.onDrawerStateChanged(newState, drawerWillShow);\n  };\n\n  _openingHandlerStateChange = ({ nativeEvent }) => {\n    if (nativeEvent.oldState === State.ACTIVE) {\n      this._handleRelease(nativeEvent);\n    } else if (nativeEvent.state === State.ACTIVE) {\n      this._emitStateChanged(DRAGGING, false);\n      if (this.props.keyboardDismissMode === 'on-drag') {\n        Keyboard.dismiss();\n      }\n      if (this.props.hideStatusBar) {\n        StatusBar.setHidden(true, this.props.statusBarAnimation || 'slide');\n      }\n    }\n  };\n\n  _onTapHandlerStateChange = ({ nativeEvent }) => {\n    if (this.state.drawerShown && nativeEvent.oldState === State.ACTIVE && this.props.drawerLockMode !== 'locked-open') {\n      this.closeDrawer();\n    }\n  };\n\n  _handleRelease = nativeEvent => {\n    const { drawerWidth, drawerPosition, drawerType } = this.props;\n    const { drawerShown, containerWidth } = this.state;\n    let { translationX: dragX, velocityX, x: touchX } = nativeEvent;\n\n    if (drawerPosition !== 'left') {\n      // See description in _updateAnimatedEvent about why events are flipped\n      // for right-side drawer\n      dragX = -dragX;\n      touchX = containerWidth - touchX;\n      velocityX = -velocityX;\n    }\n\n    const gestureStartX = touchX - dragX;\n    let dragOffsetBasedOnStart = 0;\n\n    if (drawerType === 'front') {\n      dragOffsetBasedOnStart = gestureStartX > drawerWidth ? gestureStartX - drawerWidth : 0;\n    }\n\n    const startOffsetX = dragX + dragOffsetBasedOnStart + (drawerShown ? drawerWidth : 0);\n    const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;\n\n    const shouldOpen = projOffsetX > drawerWidth / 2;\n\n    if (shouldOpen) {\n      this._animateDrawer({\n        fromValue: startOffsetX,\n        toValue: drawerWidth,\n        velocity: velocityX\n      });\n    } else {\n      this._animateDrawer({\n        fromValue: startOffsetX,\n        toValue: 0,\n        velocity: velocityX\n      });\n    }\n  };\n\n  _animateDrawer = ({\n    fromValue,\n    toValue,\n    velocity\n  }) => {\n    this.state.dragX.setValue(0);\n    this.state.touchX.setValue(this.props.drawerPosition === 'left' ? 0 : this.state.containerWidth);\n\n    if (typeof fromValue === 'number') {\n      this.state.drawerTranslation.setValue(fromValue);\n    }\n\n    const willShow = toValue !== 0;\n    this.setState({ drawerShown: willShow });\n    this._emitStateChanged(SETTLING, willShow);\n    if (this.props.hideStatusBar) {\n      StatusBar.setHidden(willShow, this.props.statusBarAnimation || 'slide');\n    }\n    Animated.spring(this.state.drawerTranslation, {\n      velocity,\n      bounciness: 0,\n      toValue,\n      useNativeDriver: this.props.useNativeAnimations\n    }).start(({ finished }) => {\n      if (finished) {\n        this._emitStateChanged(IDLE, willShow);\n        if (willShow) {\n          this.props.onDrawerOpen && this.props.onDrawerOpen();\n        } else {\n          this.props.onDrawerClose && this.props.onDrawerClose();\n        }\n      }\n    });\n  };\n\n  openDrawer = (options = {}) => {\n    this._animateDrawer({\n      toValue: this.props.drawerWidth,\n      velocity: options.velocity ? options.velocity : 0\n    });\n  };\n\n  closeDrawer = (options = {}) => {\n    this._animateDrawer({\n      toValue: 0,\n      velocity: options.velocity ? options.velocity : 0\n    });\n  };\n\n  _renderOverlay = () => {\n    /* Overlay styles */\n    invariant(this._openValue, 'should be set');\n    const overlayOpacity = this._openValue.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, 0.7],\n      extrapolate: 'clamp'\n    });\n    const dynamicOverlayStyles = {\n      opacity: overlayOpacity,\n      backgroundColor: this.props.overlayColor\n    };\n    return <TapGestureHandler onHandlerStateChange={this._onTapHandlerStateChange}>\n        <Animated.View pointerEvents={this.state.drawerShown ? 'auto' : 'none'} style={[styles.overlay, dynamicOverlayStyles]} />\n      </TapGestureHandler>;\n  };\n\n  _renderDrawer = () => {\n    const { drawerShown } = this.state;\n    const {\n      drawerBackgroundColor,\n      drawerWidth,\n      drawerPosition,\n      drawerType,\n      contentContainerStyle\n    } = this.props;\n\n    const fromLeft = drawerPosition === 'left';\n    const drawerSlide = drawerType !== 'back';\n    const containerSlide = drawerType !== 'front';\n\n    const dynamicDrawerStyles = {\n      backgroundColor: drawerBackgroundColor,\n      width: drawerWidth\n    };\n    const openValue = this._openValue;\n    invariant(openValue, 'should be set');\n\n    let containerStyles;\n    if (containerSlide) {\n      const containerTranslateX = openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: fromLeft ? [0, drawerWidth] : [0, -drawerWidth],\n        extrapolate: 'clamp'\n      });\n      containerStyles = {\n        transform: [{ translateX: containerTranslateX }]\n      };\n    }\n\n    let drawerTranslateX = 0;\n    if (drawerSlide) {\n      const closedDrawerOffset = fromLeft ? -drawerWidth : drawerWidth;\n      drawerTranslateX = openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: [closedDrawerOffset, 0],\n        extrapolate: 'clamp'\n      });\n    }\n    const drawerStyles = {\n      transform: [{ translateX: drawerTranslateX }],\n      flexDirection: (I18nManager.isRTL ? !fromLeft : fromLeft) ? 'row' : 'row-reverse'\n    };\n\n    return <Animated.View style={styles.main} onLayout={this._handleContainerLayout}>\n        <Animated.View style={[drawerType === 'front' ? styles.containerOnBack : styles.containerInFront, containerStyles, contentContainerStyle]}>\n          {typeof this.props.children === 'function' ? this.props.children(this._openValue) : this.props.children}\n          {this._renderOverlay()}\n        </Animated.View>\n        <Animated.View pointerEvents=\"box-none\" accessibilityViewIsModal={drawerShown} style={[styles.drawerContainer, drawerStyles]}>\n          <View style={[styles.drawer, dynamicDrawerStyles]}>\n            {this.props.renderNavigationView(this._openValue)}\n          </View>\n        </Animated.View>\n      </Animated.View>;\n  };\n\n  render() {\n    const { drawerShown, containerWidth } = this.state;\n\n    const {\n      drawerPosition,\n      drawerType,\n      drawerLockMode,\n      edgeWidth,\n      minSwipeDistance\n    } = this.props;\n\n    const fromLeft = drawerPosition === 'left';\n\n    // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise\n    // e.g. when drawer is on the left and is closed we expect left to right gesture, thus\n    // orientation will be 1.\n    const gestureOrientation = (fromLeft ? 1 : -1) * (drawerShown ? -1 : 1);\n\n    // When drawer is closed we want the hitSlop to be horizontally shorter\n    // than the container size by the value of SLOP. This will make it only\n    // activate when gesture happens not further than SLOP away from the edge\n    const hitSlop = fromLeft ? { right: drawerShown ? 0 : edgeWidth - containerWidth } : { left: drawerShown ? 0 : edgeWidth - containerWidth };\n\n    return <PanGestureHandler hitSlop={hitSlop} minOffsetX={gestureOrientation * minSwipeDistance} maxDeltaY={15} onGestureEvent={this._onGestureEvent} enabled={drawerLockMode !== 'locked-closed' && drawerLockMode !== 'locked-open'} onHandlerStateChange={this._openingHandlerStateChange} ref={this.props.gestureRef}>\n        {this._renderDrawer()}\n      </PanGestureHandler>;\n  }\n}\n\nconst styles = StyleSheet.create({\n  drawer: { flex: 0 },\n  drawerContainer: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1001,\n    flexDirection: 'row'\n  },\n  containerInFront: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1002\n  },\n  containerOnBack: {\n    ...StyleSheet.absoluteFillObject\n  },\n  main: {\n    flex: 1,\n    zIndex: 0,\n    overflow: 'hidden'\n  },\n  overlay: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1000\n  }\n});"]},"metadata":{},"sourceType":"module"}