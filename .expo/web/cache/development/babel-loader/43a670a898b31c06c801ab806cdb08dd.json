{"ast":null,"code":"import Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport getSceneIndicesForInterpolationInputRange from \"../../utils/getSceneIndicesForInterpolationInputRange\";\n\nfunction hasHeader(scene) {\n  if (!scene) {\n    return true;\n  }\n\n  var descriptor = scene.descriptor;\n  return descriptor.options.header !== null;\n}\n\nvar crossFadeInterpolation = function crossFadeInterpolation(scenes, first, index, last) {\n  return {\n    inputRange: [first, first + 0.001, index - 0.9, index - 0.2, index, last - 0.001, last],\n    outputRange: [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0.3 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0 : 1, 0],\n    extrapolate: 'clamp'\n  };\n};\n\nfunction isGoingBack(scenes) {\n  var lastSceneIndexInScenes = scenes.length - 1;\n  return !scenes[lastSceneIndexInScenes].isActive;\n}\n\nfunction forLayout(props) {\n  var layout = props.layout,\n      position = props.position,\n      scene = props.scene,\n      scenes = props.scenes,\n      mode = props.mode;\n\n  if (mode !== 'float') {\n    return {};\n  }\n\n  var isBack = isGoingBack(scenes);\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {};\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var width = layout.initWidth || Dimensions.get('window').width;\n\n  if (isBack && !hasHeader(scenes[index]) && !hasHeader(scenes[last]) || !isBack && !hasHeader(scenes[first]) && !hasHeader(scenes[index])) {\n    return {\n      transform: [{\n        translateX: width\n      }]\n    };\n  }\n\n  var rtlMult = I18nManager.isRTL ? -1 : 1;\n  var translateX = position.interpolate({\n    inputRange: [first, index, last],\n    outputRange: [rtlMult * (hasHeader(scenes[first]) ? 0 : width), rtlMult * (hasHeader(scenes[index]) ? 0 : isBack ? width : -width), rtlMult * (hasHeader(scenes[last]) ? 0 : -width)],\n    extrapolate: 'clamp'\n  });\n  return {\n    transform: [{\n      translateX: translateX\n    }]\n  };\n}\n\nfunction forLeft(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(scenes, first, index, last))\n  };\n}\n\nfunction forCenter(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(scenes, first, index, last))\n  };\n}\n\nfunction forRight(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(scenes, first, index, last))\n  };\n}\n\nfunction forLeftButton(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var inputRange = [first, first + 0.001, first + Math.abs(index - first) / 2, index, last - Math.abs(last - index) / 2, last - 0.001, last];\n  var outputRange = [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0.3 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0.3 : 1, hasHeader(scenes[last]) ? 0 : 1, 0];\n  return {\n    opacity: position.interpolate({\n      inputRange: inputRange,\n      outputRange: outputRange,\n      extrapolate: 'clamp'\n    })\n  };\n}\n\nvar LEFT_LABEL_OFFSET = Dimensions.get('window').width / 2 - 70 - 25;\n\nfunction forLeftLabel(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var offset = LEFT_LABEL_OFFSET;\n  return {\n    opacity: position.interpolate({\n      inputRange: [first, first + 0.001, index - 0.35, index, index + 0.5, last - 0.001, last],\n      outputRange: [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0.5 : 1, hasHeader(scenes[last]) ? 0 : 1, 0],\n      extrapolate: 'clamp'\n    }),\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, first + 0.001, index, last - 0.001, last],\n        outputRange: I18nManager.isRTL ? [-offset * 1.5, hasHeader(scenes[first]) ? -offset * 1.5 : 0, 0, hasHeader(scenes[last]) ? offset : 0, offset] : [offset, hasHeader(scenes[first]) ? offset : 0, 0, hasHeader(scenes[last]) ? -offset * 1.5 : 0, -offset * 1.5],\n        extrapolate: 'clamp'\n      })\n    }]\n  };\n}\n\nvar TITLE_OFFSET_IOS = Dimensions.get('window').width / 2 - 70 + 25;\n\nfunction forCenterFromLeft(props) {\n  var position = props.position,\n      scene = props.scene,\n      scenes = props.scenes;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var offset = TITLE_OFFSET_IOS;\n  return {\n    opacity: position.interpolate({\n      inputRange: [first, first + 0.001, index - 0.5, index, index + 0.7, last - 0.001, last],\n      outputRange: [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0 : 1, hasHeader(scenes[last]) ? 0 : 1, 0],\n      extrapolate: 'clamp'\n    }),\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, first + 0.001, index, last - 0.001, last],\n        outputRange: I18nManager.isRTL ? [-offset, hasHeader(scenes[first]) ? -offset : 0, 0, hasHeader(scenes[last]) ? offset : 0, offset] : [offset, hasHeader(scenes[first]) ? offset : 0, 0, hasHeader(scenes[last]) ? -offset : 0, -offset],\n        extrapolate: 'clamp'\n      })\n    }]\n  };\n}\n\nfunction forBackgroundWithFade(props) {\n  var position = props.position,\n      scene = props.scene;\n  var sceneRange = getSceneIndicesForInterpolationInputRange(props);\n  if (!sceneRange) return {\n    opacity: 0\n  };\n  return {\n    opacity: position.interpolate({\n      inputRange: [sceneRange.first, scene.index, sceneRange.last],\n      outputRange: [0, 1, 0],\n      extrapolate: 'clamp'\n    })\n  };\n}\n\nvar VISIBLE = {\n  opacity: 1\n};\nvar HIDDEN = {\n  opacity: 0\n};\n\nfunction forBackgroundWithInactiveHidden(_ref) {\n  var navigation = _ref.navigation,\n      scene = _ref.scene;\n  return navigation.state.index === scene.index ? VISIBLE : HIDDEN;\n}\n\nvar BACKGROUND_OFFSET = Dimensions.get('window').width;\n\nfunction forBackgroundWithTranslation(props) {\n  var position = props.position,\n      scene = props.scene;\n  var interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {\n    opacity: 0\n  };\n  var first = interpolate.first,\n      last = interpolate.last;\n  var index = scene.index;\n  var offset = BACKGROUND_OFFSET;\n  var outputRange = [offset, 0, -offset];\n  return {\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, index, last],\n        outputRange: I18nManager.isRTL ? outputRange.reverse() : outputRange,\n        extrapolate: 'clamp'\n      })\n    }]\n  };\n}\n\nvar forBackground = forBackgroundWithInactiveHidden;\nexport default {\n  forLayout: forLayout,\n  forLeft: forLeft,\n  forLeftButton: forLeftButton,\n  forLeftLabel: forLeftLabel,\n  forCenterFromLeft: forCenterFromLeft,\n  forCenter: forCenter,\n  forRight: forRight,\n  forBackground: forBackground,\n  forBackgroundWithInactiveHidden: forBackgroundWithInactiveHidden,\n  forBackgroundWithFade: forBackgroundWithFade,\n  forBackgroundWithTranslation: forBackgroundWithTranslation\n};","map":{"version":3,"sources":["/Users/devonhubert/languages/javascript/react_native/PayCheck/node_modules/react-navigation-stack/dist/views/Header/HeaderStyleInterpolator.js"],"names":["getSceneIndicesForInterpolationInputRange","hasHeader","scene","descriptor","options","header","crossFadeInterpolation","scenes","first","index","last","inputRange","outputRange","extrapolate","isGoingBack","lastSceneIndexInScenes","length","isActive","forLayout","props","layout","position","mode","isBack","interpolate","width","initWidth","Dimensions","get","transform","translateX","rtlMult","I18nManager","isRTL","forLeft","opacity","forCenter","forRight","forLeftButton","Math","abs","LEFT_LABEL_OFFSET","forLeftLabel","offset","TITLE_OFFSET_IOS","forCenterFromLeft","forBackgroundWithFade","sceneRange","VISIBLE","HIDDEN","forBackgroundWithInactiveHidden","navigation","state","BACKGROUND_OFFSET","forBackgroundWithTranslation","reverse","forBackground"],"mappings":"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","sourcesContent":["import { Dimensions, I18nManager } from 'react-native';\nimport getSceneIndicesForInterpolationInputRange from '../../utils/getSceneIndicesForInterpolationInputRange';\n\nfunction hasHeader(scene) {\n  if (!scene) {\n    return true;\n  }\n  const { descriptor } = scene;\n  return descriptor.options.header !== null;\n}\n\nconst crossFadeInterpolation = (scenes, first, index, last) => ({\n  inputRange: [first, first + 0.001, index - 0.9, index - 0.2, index, last - 0.001, last],\n  outputRange: [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0.3 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0 : 1, 0],\n  extrapolate: 'clamp'\n});\n\n/**\n * Utilities that build the style for the navigation header.\n *\n * +-------------+-------------+-------------+\n * |             |             |             |\n * |    Left     |   Title     |   Right     |\n * |  Component  |  Component  | Component   |\n * |             |             |             |\n * +-------------+-------------+-------------+\n */\n\nfunction isGoingBack(scenes) {\n  const lastSceneIndexInScenes = scenes.length - 1;\n  return !scenes[lastSceneIndexInScenes].isActive;\n}\n\nfunction forLayout(props) {\n  const { layout, position, scene, scenes, mode } = props;\n  if (mode !== 'float') {\n    return {};\n  }\n  const isBack = isGoingBack(scenes);\n\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return {};\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  // We really shouldn't render the scene at all until we know the width of the\n  // stack. That said, in every case that I have ever seen, this has just been\n  // the full width of the window. This won't continue to be true if we support\n  // layouts like iPad master-detail. For now, in order to solve\n  // https://github.com/react-navigation/react-navigation/issues/4264, I have\n  // opted for the heuristic that we will use the window width until we have\n  // measured (and they will usually be the same).\n  const width = layout.initWidth || Dimensions.get('window').width;\n\n  // Make sure the header stays hidden when transitioning between 2 screens\n  // with no header.\n  if (isBack && !hasHeader(scenes[index]) && !hasHeader(scenes[last]) || !isBack && !hasHeader(scenes[first]) && !hasHeader(scenes[index])) {\n    return {\n      transform: [{ translateX: width }]\n    };\n  }\n\n  const rtlMult = I18nManager.isRTL ? -1 : 1;\n  const translateX = position.interpolate({\n    inputRange: [first, index, last],\n    outputRange: [rtlMult * (hasHeader(scenes[first]) ? 0 : width), rtlMult * (hasHeader(scenes[index]) ? 0 : isBack ? width : -width), rtlMult * (hasHeader(scenes[last]) ? 0 : -width)],\n    extrapolate: 'clamp'\n  });\n\n  return {\n    transform: [{ translateX }]\n  };\n}\n\nfunction forLeft(props) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(scenes, first, index, last))\n  };\n}\n\nfunction forCenter(props) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(scenes, first, index, last))\n  };\n}\n\nfunction forRight(props) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  return {\n    opacity: position.interpolate(crossFadeInterpolation(scenes, first, index, last))\n  };\n}\n\n/**\n * iOS UINavigationController style interpolators\n */\n\nfunction forLeftButton(props) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  // The gist of what we're doing here is animating the left button _normally_ (fast fade)\n  // when both scenes in transition have headers. When the current, next, or previous scene _don't_\n  // have a header, we don't fade the button, and only set it's opacity to 0 at the last moment\n  // of the transition.\n  const inputRange = [first, first + 0.001, first + Math.abs(index - first) / 2, index, last - Math.abs(last - index) / 2, last - 0.001, last];\n  const outputRange = [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0.3 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0.3 : 1, hasHeader(scenes[last]) ? 0 : 1, 0];\n\n  return {\n    opacity: position.interpolate({\n      inputRange,\n      outputRange,\n      extrapolate: 'clamp'\n    })\n  };\n}\n\n/*\n * NOTE: this offset calculation is an approximation that gives us\n * decent results in many cases, but it is ultimately a poor substitute\n * for text measurement. See the comment on title for more information.\n *\n * - 70 is the width of the left button area.\n * - 25 is the width of the left button icon (to account for label offset)\n */\nconst LEFT_LABEL_OFFSET = Dimensions.get('window').width / 2 - 70 - 25;\nfunction forLeftLabel(props) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n\n  const offset = LEFT_LABEL_OFFSET;\n\n  // Similarly to the animation of the left label, when animating to or from a scene without\n  // a header, we keep the label at full opacity and in the same position for as long as possible.\n  return {\n    // For now we fade out the label before fading in the title, so the\n    // differences between the label and title position can be hopefully not so\n    // noticable to the user\n    opacity: position.interpolate({\n      inputRange: [first, first + 0.001, index - 0.35, index, index + 0.5, last - 0.001, last],\n      outputRange: [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0.5 : 1, hasHeader(scenes[last]) ? 0 : 1, 0],\n      extrapolate: 'clamp'\n    }),\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, first + 0.001, index, last - 0.001, last],\n        outputRange: I18nManager.isRTL ? [-offset * 1.5, hasHeader(scenes[first]) ? -offset * 1.5 : 0, 0, hasHeader(scenes[last]) ? offset : 0, offset] : [offset, hasHeader(scenes[first]) ? offset : 0, 0, hasHeader(scenes[last]) ? -offset * 1.5 : 0, -offset * 1.5],\n        extrapolate: 'clamp'\n      })\n    }]\n  };\n}\n\n/*\n * NOTE: this offset calculation is a an approximation that gives us\n * decent results in many cases, but it is ultimately a poor substitute\n * for text measurement. We want the back button label to transition\n * smoothly into the title text and to do this we need to understand\n * where the title is positioned within the title container (since it is\n * centered).\n *\n * - 70 is the width of the left button area.\n * - 25 is the width of the left button icon (to account for label offset)\n */\nconst TITLE_OFFSET_IOS = Dimensions.get('window').width / 2 - 70 + 25;\nfunction forCenterFromLeft(props) {\n  const { position, scene, scenes } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n\n  if (!interpolate) return { opacity: 0 };\n\n  const { first, last } = interpolate;\n  const index = scene.index;\n  const offset = TITLE_OFFSET_IOS;\n\n  return {\n    opacity: position.interpolate({\n      inputRange: [first, first + 0.001, index - 0.5, index, index + 0.7, last - 0.001, last],\n      outputRange: [0, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[first]) ? 0 : 1, hasHeader(scenes[index]) ? 1 : 0, hasHeader(scenes[last]) ? 0 : 1, hasHeader(scenes[last]) ? 0 : 1, 0],\n      extrapolate: 'clamp'\n    }),\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, first + 0.001, index, last - 0.001, last],\n        outputRange: I18nManager.isRTL ? [-offset, hasHeader(scenes[first]) ? -offset : 0, 0, hasHeader(scenes[last]) ? offset : 0, offset] : [offset, hasHeader(scenes[first]) ? offset : 0, 0, hasHeader(scenes[last]) ? -offset : 0, -offset],\n        extrapolate: 'clamp'\n      })\n    }]\n  };\n}\n\n// Fade in background of header while transitioning\nfunction forBackgroundWithFade(props) {\n  const { position, scene } = props;\n  const sceneRange = getSceneIndicesForInterpolationInputRange(props);\n  if (!sceneRange) return { opacity: 0 };\n  return {\n    opacity: position.interpolate({\n      inputRange: [sceneRange.first, scene.index, sceneRange.last],\n      outputRange: [0, 1, 0],\n      extrapolate: 'clamp'\n    })\n  };\n}\n\nconst VISIBLE = { opacity: 1 };\nconst HIDDEN = { opacity: 0 };\n\n// Toggle visibility of header without fading\nfunction forBackgroundWithInactiveHidden({ navigation, scene }) {\n  return navigation.state.index === scene.index ? VISIBLE : HIDDEN;\n}\n\n// Translate the background with the card\nconst BACKGROUND_OFFSET = Dimensions.get('window').width;\nfunction forBackgroundWithTranslation(props) {\n  const { position, scene } = props;\n  const interpolate = getSceneIndicesForInterpolationInputRange(props);\n  if (!interpolate) return { opacity: 0 };\n  const { first, last } = interpolate;\n  const index = scene.index;\n  const offset = BACKGROUND_OFFSET;\n  const outputRange = [offset, 0, -offset];\n  return {\n    transform: [{\n      translateX: position.interpolate({\n        inputRange: [first, index, last],\n        outputRange: I18nManager.isRTL ? outputRange.reverse() : outputRange,\n        extrapolate: 'clamp'\n      })\n    }]\n  };\n}\n\n// Default to fade transition\nconst forBackground = forBackgroundWithInactiveHidden;\n\nexport default {\n  forLayout,\n  forLeft,\n  forLeftButton,\n  forLeftLabel,\n  forCenterFromLeft,\n  forCenter,\n  forRight,\n  forBackground,\n  forBackgroundWithInactiveHidden,\n  forBackgroundWithFade,\n  forBackgroundWithTranslation\n};"]},"metadata":{},"sourceType":"module"}