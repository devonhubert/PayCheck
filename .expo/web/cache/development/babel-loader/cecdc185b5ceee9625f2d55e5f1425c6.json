{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport invariant from \"../utils/invariant\";\nimport shallowEqual from \"../utils/shallowEqual\";\nvar SCENE_KEY_PREFIX = 'scene_';\n\nfunction compareKey(one, two) {\n  var delta = one.length - two.length;\n\n  if (delta > 0) {\n    return 1;\n  }\n\n  if (delta < 0) {\n    return -1;\n  }\n\n  return one > two ? 1 : -1;\n}\n\nfunction compareScenes(one, two) {\n  if (one.index > two.index) {\n    return 1;\n  }\n\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\nfunction areScenesShallowEqual(one, two) {\n  return one.key === two.key && one.index === two.index && one.isStale === two.isStale && one.isActive === two.isActive && areRoutesShallowEqual(one.route, two.route);\n}\n\nfunction areRoutesShallowEqual(one, two) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(scenes, nextState, prevState, descriptors) {\n  scenes.forEach(function (scene) {\n    var route = scene.route;\n\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  });\n\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  var prevScenes = new Map();\n  var freshScenes = new Map();\n  var staleScenes = new Map();\n  scenes.forEach(function (scene) {\n    var key = scene.key;\n\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n\n    prevScenes.set(key, scene);\n  });\n  var nextKeys = new Set();\n  var nextRoutes = nextState.routes;\n\n  if (nextRoutes.length > nextState.index + 1) {\n    console.warn('StackRouter provided invalid state, index should always be the top route');\n    nextRoutes = nextState.routes.slice(0, nextState.index + 1);\n  }\n\n  nextRoutes.forEach(function (route, index) {\n    var key = SCENE_KEY_PREFIX + route.key;\n    var descriptor = descriptors && descriptors[route.key];\n    var scene = {\n      index: index,\n      isActive: false,\n      isStale: false,\n      key: key,\n      route: route,\n      descriptor: descriptor\n    };\n    invariant(!nextKeys.has(key), \"navigation.state.routes[\" + index + \"].key \\\"\" + key + \"\\\" conflicts with \" + 'another route!');\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      staleScenes.delete(key);\n    }\n\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    var prevRoutes = prevState.routes;\n\n    if (prevRoutes.length > prevState.index + 1) {\n      console.warn('StackRouter provided invalid state, index should always be the top route');\n      prevRoutes = prevRoutes.slice(0, prevState.index + 1);\n    }\n\n    prevRoutes.forEach(function (route, index) {\n      var key = SCENE_KEY_PREFIX + route.key;\n\n      if (freshScenes.has(key)) {\n        return;\n      }\n\n      var lastScene = scenes.find(function (scene) {\n        return scene.route.key === route.key;\n      });\n      var descriptor = lastScene ? lastScene.descriptor : descriptors[route.key];\n\n      if (descriptor) {\n        staleScenes.set(key, {\n          index: index,\n          isActive: false,\n          isStale: true,\n          key: key,\n          route: route,\n          descriptor: descriptor\n        });\n      }\n    });\n  }\n\n  var nextScenes = [];\n\n  var mergeScene = function mergeScene(nextScene) {\n    var key = nextScene.key;\n    var prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n  nextScenes.sort(compareScenes);\n  var activeScenesCount = 0;\n  nextScenes.forEach(function (scene, ii) {\n    var isActive = !scene.isStale && scene.index === nextState.index;\n\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = _objectSpread(_objectSpread({}, scene), {}, {\n        isActive: isActive\n      });\n    }\n\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n  invariant(activeScenesCount === 1, 'there should always be only one scene active, not %s.', activeScenesCount);\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (nextScenes.some(function (scene, index) {\n    return !areScenesShallowEqual(scenes[index], scene);\n  })) {\n    return nextScenes;\n  }\n\n  return scenes;\n}","map":{"version":3,"sources":["/Users/devonhubert/languages/javascript/react_native/PayCheck/node_modules/react-navigation-stack/dist/views/ScenesReducer.js"],"names":["invariant","shallowEqual","SCENE_KEY_PREFIX","compareKey","one","two","delta","length","compareScenes","index","key","areScenesShallowEqual","isStale","isActive","areRoutesShallowEqual","route","ScenesReducer","scenes","nextState","prevState","descriptors","forEach","scene","descriptor","prevScenes","Map","freshScenes","staleScenes","set","nextKeys","Set","nextRoutes","routes","console","warn","slice","has","add","delete","prevRoutes","lastScene","find","nextScenes","mergeScene","nextScene","prevScene","get","push","sort","activeScenesCount","ii","some"],"mappings":"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","sourcesContent":["import invariant from '../utils/invariant';\nimport shallowEqual from '../utils/shallowEqual';\n\nconst SCENE_KEY_PREFIX = 'scene_';\n\n/**\n * Helper function to compare route keys (e.g. \"9\", \"11\").\n */\nfunction compareKey(one, two) {\n  const delta = one.length - two.length;\n  if (delta > 0) {\n    return 1;\n  }\n  if (delta < 0) {\n    return -1;\n  }\n  return one > two ? 1 : -1;\n}\n\n/**\n * Helper function to sort scenes based on their index and view key.\n */\nfunction compareScenes(one, two) {\n  if (one.index > two.index) {\n    return 1;\n  }\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areScenesShallowEqual(one, two) {\n  return one.key === two.key && one.index === two.index && one.isStale === two.isStale && one.isActive === two.isActive && areRoutesShallowEqual(one.route, two.route);\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areRoutesShallowEqual(one, two) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(scenes, nextState, prevState, descriptors) {\n  // Always update the descriptors\n  // This is a workaround for https://github.com/react-navigation/react-navigation/issues/4271\n  // It will be resolved in a better way when we re-write Transitioner\n  scenes.forEach(scene => {\n    const { route } = scene;\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  });\n\n  // Bail out early if we didn't update the state\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  const prevScenes = new Map();\n  const freshScenes = new Map();\n  const staleScenes = new Map();\n\n  // Populate stale scenes from previous scenes marked as stale.\n  scenes.forEach(scene => {\n    const { key } = scene;\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n    prevScenes.set(key, scene);\n  });\n\n  const nextKeys = new Set();\n  let nextRoutes = nextState.routes;\n  if (nextRoutes.length > nextState.index + 1) {\n    console.warn('StackRouter provided invalid state, index should always be the top route');\n    nextRoutes = nextState.routes.slice(0, nextState.index + 1);\n  }\n\n  nextRoutes.forEach((route, index) => {\n    const key = SCENE_KEY_PREFIX + route.key;\n\n    let descriptor = descriptors && descriptors[route.key];\n\n    const scene = {\n      index,\n      isActive: false,\n      isStale: false,\n      key,\n      route,\n      descriptor\n    };\n    invariant(!nextKeys.has(key), `navigation.state.routes[${index}].key \"${key}\" conflicts with ` + 'another route!');\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      // A previously `stale` scene is now part of the nextState, so we\n      // revive it by removing it from the stale scene map.\n      staleScenes.delete(key);\n    }\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    let prevRoutes = prevState.routes;\n    if (prevRoutes.length > prevState.index + 1) {\n      console.warn('StackRouter provided invalid state, index should always be the top route');\n      prevRoutes = prevRoutes.slice(0, prevState.index + 1);\n    }\n    // Look at the previous routes and classify any removed scenes as `stale`.\n    prevRoutes.forEach((route, index) => {\n      const key = SCENE_KEY_PREFIX + route.key;\n      if (freshScenes.has(key)) {\n        return;\n      }\n      const lastScene = scenes.find(scene => scene.route.key === route.key);\n\n      // We can get into a weird place where we have a queued transition and then clobber\n      // that transition without ever actually rendering the scene, in which case\n      // there is no lastScene. If the descriptor is not available on the lastScene\n      // or the descriptors prop then we just skip adding it to stale scenes and it's\n      // not ever rendered.\n      const descriptor = lastScene ? lastScene.descriptor : descriptors[route.key];\n\n      if (descriptor) {\n        staleScenes.set(key, {\n          index,\n          isActive: false,\n          isStale: true,\n          key,\n          route,\n          descriptor\n        });\n      }\n    });\n  }\n\n  const nextScenes = [];\n\n  const mergeScene = nextScene => {\n    const { key } = nextScene;\n    const prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      // Reuse `prevScene` as `scene` so view can avoid unnecessary re-render.\n      // This assumes that the scene's navigation state is immutable.\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n\n  nextScenes.sort(compareScenes);\n\n  let activeScenesCount = 0;\n  nextScenes.forEach((scene, ii) => {\n    const isActive = !scene.isStale && scene.index === nextState.index;\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = {\n        ...scene,\n        isActive\n      };\n    }\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n\n  invariant(activeScenesCount === 1, 'there should always be only one scene active, not %s.', activeScenesCount);\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (nextScenes.some((scene, index) => !areScenesShallowEqual(scenes[index], scene))) {\n    return nextScenes;\n  }\n\n  // scenes haven't changed.\n  return scenes;\n}"]},"metadata":{},"sourceType":"module"}